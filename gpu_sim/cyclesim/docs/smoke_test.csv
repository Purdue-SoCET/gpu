Test	Type	Scenario	Preconditions & Setup	Stimulus	Expected Result	Checks
IBUF-1	iBuffer	Single enqueue into empty WG FIFO	IssueStage fresh init; WG0 capacity=0 head=0; inst_in.warp_group_id=0	cycle0: compute(inst0)	WG0 capacity increments by 1; inst stored at tail=(head+oldcap)%4; no pop unless staged slots empty and FU_stall=False on same cycle ordering (staging happens before fill).	"Check iBuffer[0][tail]==inst0, iBufferCapacity[0]==1, iBufferHead[0]==0"
IBUF-2	iBuffer	Enqueue up to declared max capacity (off-by-one detection)	Fresh init; num_entries=4	Feed 4 instructions to same WG across 4 cycles with FU_stall forcing no dequeue	Expected architectural intent: capacity should reach 4 and then refuse 5th. Current code allows only up to 3 (<= num_entries-1). Test should catch mismatch.	Check iBufferCapacity[wg] reaches expected max; verify 4th enqueue accepted or rejected per spec; assert no overwrite.
IBUF-3	iBuffer	Head/tail wrap-around correctness	"Preload WG0 FIFO with 3 inst; set head near end (e.g., head=3, cap=2) by controlled pops"	Push 2 more inst with pops in between to force wrap	Tail index wraps modulo 4; ordering preserved; no None gaps in logical FIFO region	"Inspect iBuffer slots, iBufferHead progression, capacity after each op."
IBUF-4	iBuffer	Per-warp-group isolation	Fresh init	"Interleave enqueues: WG0, WG1, WG0, WG1"	Each WG maintains independent head/capacity; no cross-contamination	"Check iBufferCapacity[0]==2, iBufferCapacity[1]==2; correct instructions in each FIFO."
IBUF-5	iBuffer	No dequeue when curr_wg empty	"WG0 empty, WG1 has insts; curr_wg points to WG0"	compute(None) with curr_wg=0 (or feed inst targeting WG0)	No staging occurs (because _pop_from_ibuffer_matching only uses curr_wg); WG1 remains untouched	Check staged_even/odd remain None; WG1 FIFO unchanged.
IBUF-6	iBuffer	Dequeue only if predicate matches warp parity	WG0 FIFO head has odd warp_id instruction; staged_even empty; staged_odd empty; curr_wg=0	compute(None) with FU free	EVEN staging should not pop odd instruction; ODD staging should pop it	Check staged_even stays None; staged_odd==that instruction; capacity decremented by 1.
IBUF-7	iBuffer	Round-robin pointer behavior (curr_wg update)	Feed instruction with warp_group_id=5 then stop inputs	cycle0: compute(inst wg=5); cycle1..k: compute(None)	curr_wg should remain 5 across None inputs; staging/dequeue continues servicing WG5	Check curr_wg value over cycles; confirm dequeue from WG5 continues.
STG-1	Staging	Stage EVEN then ODD when both empty and both available	"WG0 FIFO has head even warp_id, next odd warp_id; FU free; staged slots empty"	compute(None) for several cycles after enqueues	"EVEN slot filled first (if empty), then ODD; both point to correct instructions without skipping"	"Check staged_even is even inst, staged_odd is odd inst after staging step."
STG-2	Staging	Do not overwrite staged slot if already occupied	staged_even already holds inst awaiting reads; WG FIFO has more even insts	compute(None)	staged_even unchanged; no additional pop for even until slot clears	Check staged_even identity unchanged; iBufferCapacity unchanged for even candidates.
RF-1	RF Reads	EVEN bank reads rs1 then rs2 across two cycles	staged_even populated; regfile contains known values	cycle0 compute(None); cycle1 compute(None)	"cycle0 sets rdat1 and progress=1; cycle1 sets rdat2, pushes to ready queue, clears staged_even"	Check rdat1 after cycle0; rdat2 after cycle1; ready_to_dispatch length increments after cycle1.
RF-2	RF Reads	ODD bank reads rs1 then rs2 across two cycles	staged_odd populated; regfile contains known values	cycle0 compute(None); cycle1 compute(None)	Same as RF-001 but for odd path	Check rdat1/rdat2 and progress reset.
RF-3	RF Reads	Steady-state oscillation with both banks active	WG FIFO supplies alternating even/odd instructions continuously; FU free	Run 6 cycles with enough enqueued insts	"Expected pattern: once both banks busy, each cycle performs 1 read per bank; produces overlapping completion (even completes every other cycle; odd completes every other cycle offset)"	Track per-cycle which operand read occurred (rdat1 vs rdat2) for each instruction; ensure no bank does >1 read/cycle.
RF-4	RF Reads	Correct warp_id used for regfile bank/warp indexing	Two instructions: same rs regs but different warp_id with different RF contents	Stage and read both	Each instruction receives operands from its own warp_id's registers	Check rdat values match per-warp initialization.
RF-5	RF Reads	Reads suppressed when FU_stall_issue asserted	Create condition where _dispatch_ready_via_fust returns FU_stall True (fust[inst.intended_FU]=1 with ready inst present)	cycleX: have ready_to_dispatch non-empty and FU busy; call compute(None)	"When FU_stall_issue True, IssueStage should skip _issue_register_file_reads and _stage_from_ibuffer_for_next_cycle (per current code)"	Check staged_even/odd progress unchanged; no new staging; no rdat updates this cycle.
DISP-1	Dispatch	Dispatch blocked when FU busy (global fust)	ready_to_dispatch has one inst with intended_FU='ADD'; fust['ADD']=1	compute(None)	No dispatch; FU_stall_issue True; inst remains in queue	Check dispatched output does not include inst; ready_to_dispatch still has inst.
DISP-2	Dispatch	Dispatch occurs when FU free	ready_to_dispatch has one inst; fust[intended_FU]=0	compute(None)	Inst is popped and appended to dispatched list for this cycle	Check queue length decremented; dispatched contains inst (and verify per-cycle reset behavior if spec expects).
DISP-3	Dispatch	Priority: ready_to_dispatch is FIFO	Two ready insts enqueued in order A then B; FU free	compute(None) twice	A dispatched before B	Check dispatch order matches enqueue order.
DISP-4	Dispatch	Dispatch should be per-cycle (cumulative list regression)	Run multiple cycles with dispatch events	Observe compute() return each cycle	Expected: return list contains only instructions dispatched that cycle. Current code accumulates in self.dispatched forever; test should flag.	Check len(dispatched_returned_each_cycle) resets; or explicitly clear self.dispatched at cycle start.
DISP-5	Dispatch	Ready queue gets populated only after both operands read	Stage inst and run one cycle	cycle0: compute(None)	Inst not in ready queue after only rs1 read; appears only after rs2 read on next cycle	"Check ready_to_dispatch unchanged after first read, increments after second."
FWD-1	Forwarding/Flags	iBuff_Full_Flags asserted correctly at/near full	Fill one WG FIFO to capacity threshold; num_entries=4	Enqueue 3 inst (and/or 4 depending on spec); call compute each cycle	Flags vector bit for WG asserted when capacity meets defined threshold. Current code asserts at >=3 and fill rejects 4th; test should catch desired behavior.	Check iBuff_Full_Flags[wg] transitions; verify forwarded value matches expected.
FWD-2	Forwarding/Flags	Flags clear when FIFO drains below threshold	"After FWD-001, allow staging+reads to pop entries"	Run cycles until capacity decreases	Flag bit deasserts when capacity < threshold	Check iBuff_Full_Flags[wg] toggles off; ensure other bits unchanged.
FWD-3	Forwarding/Flags	Forwarding invoked every cycle	Instrumentation/mocking of forward_signals in Stage base	Run N cycles with varying occupancy	Forwarding called each cycle with length==num_iBuffer and integer bits	Check call count==N; payload length==16; values are 0/1.
STALL-1	Stalls	Input acceptance behavior under FU stall	Set FU busy so FU_stall_issue True; provide new inst_in each cycle to same WG	cycle0..k compute(inst)	Spec choice: should likely stall upstream and NOT accept new inst while stalled. Current code still fills iBuffer even during stall; test documents and validates intended policy.	"Check whether fill_ibuffer occurred during stall; if not desired, test should fail."
STALL-2	Stalls	Input dropped/ignored when iBuffer full	Fill WG FIFO to max; then provide one more inst	compute(extra_inst)	Upstream should stall/retry; IssueStage should not overwrite existing entries	Check FIFO contents unchanged; capacity unchanged; optionally detect a 'stall' signal if implemented.
EDGE-1	Edge	compute(None) with completely empty state	Fresh init; no enqueues	compute(None) for 3 cycles	No crashes; no state changes except forwarding flags remain all zeros	Check staged slots None; capacities 0; flags all 0; ready/dispatched empty.
EDGE-2	Edge	Instruction with rs2=None or unused operand (if ISA allows)	Create Instruction where rs2 is None or set to sentinel; regfile handles?	Stage and read	Either gracefully skip rs2 read or read a defined value; test locks down expected contract	Check no exception; rdat2 matches contract.
EDGE-3	Edge	Multiple warpGroups: ensure correct WG serviced when inst_in changes	Provide insts alternating warp_group_id between 0 and 1 each cycle	Run 8 cycles	curr_wg updates to match last inst_in each cycle; staging should pull from that WG only	Check that WG0 and WG1 FIFOs dequeue only on cycles when that WG was selected.
EDGE-4	Edge	"Predicate starvation: only odd warps enqueued, even slot remains empty"	WG FIFO contains only odd warp_id instructions	Run cycles	EVEN staging remains None; ODD processes; no deadlock	Check ODD progresses; EVEN stays idle.
EDGE-5	Edge	Correct handling when iBuffer head slot unexpectedly None	Manually corrupt iBuffer[wg][head]=None while capacity>0	compute(None)	_pop_from_ibuffer_matching should return None and not crash; capacity may become inconsistent—test should detect and fail if invariants violated	Check for safe handling; optionally assert invariant enforcement.
FU-1	FUST/Gating	One test per FU type (ADD/SUB/MUL/DIV/SQRT/LDST)	For each FU name: enqueue one ready instruction with intended_FU=FU; toggle fust[FU] 1->0	Compute across two cycles per FU	When busy: no dispatch; when free: dispatch occurs; no cross-FU interference	Check dispatch behavior per FU key; verify that only matching FU gate controls dispatch.
API-1	Connection	_dispatch_ready_via_fust return type consistency	Call compute and capture FU_stall_issue plus dispatched list	Run scenario with and without FU stall	"Ensure compute uses returned bool consistently; if API refactor returns list, tests fail fast"	Static check: type assertions; runtime: FU_stall_issue is bool.
API-2	Connection	Dispatched list clearing (memory leak / growth)	Long run with periodic dispatches	Run 10k cycles in unit test	dispatched storage should not grow unbounded; either clear each cycle or cap history	Check memory/len(self.dispatched) bounded by per-cycle dispatch count.
